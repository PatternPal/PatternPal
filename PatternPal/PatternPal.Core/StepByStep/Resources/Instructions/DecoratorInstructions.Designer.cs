//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace PatternPal.Core.StepByStep.Resources.Instructions {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class DecoratorInstructions {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal DecoratorInstructions() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("PatternPal.Core.StepByStep.Resources.Instructions.DecoratorInstructions", typeof(DecoratorInstructions).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This will be the common interface for both wrappers (decorators) and wrapped objects (concrete components)..
        /// </summary>
        internal static string Explanation1 {
            get {
                return ResourceManager.GetString("Explanation1", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This class defines the basic behavior we want, which, when we are done, can be altered by decorators..
        /// </summary>
        internal static string Explanation2 {
            get {
                return ResourceManager.GetString("Explanation2", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This class is abstract, since its only job is delegating operations to the wrapped object, i.e. the field. The field needs to have Component as type, since this class should be able to both wrap concrete components and decorators. It should be private since its only purpose should be to be called in the method. The specific extra behavior will be added by classes inheriting from this class..
        /// </summary>
        internal static string Explanation3 {
            get {
                return ResourceManager.GetString("Explanation3", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This constructor is needed to actually wrap a component. It should not be private since a class inheriting from this class should be able to pass an instance of Component as parameter to the constructor..
        /// </summary>
        internal static string Explanation4 {
            get {
                return ResourceManager.GetString("Explanation4", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This call ensures a decorator will always execute the behavior of its wrapped object.
        /// </summary>
        internal static string Explanation5 {
            get {
                return ResourceManager.GetString("Explanation5", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to By calling the method of the parent, we ensure that the behaviour of the wrapped object is executed..
        /// </summary>
        internal static string Explanation6 {
            get {
                return ResourceManager.GetString("Explanation6", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Now, the decorator does really add additional behavior to the wrapped object..
        /// </summary>
        internal static string Explanation7 {
            get {
                return ResourceManager.GetString("Explanation7", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The client can now wrap components in multiple layers of decorators. .
        /// </summary>
        internal static string Explanation8 {
            get {
                return ResourceManager.GetString("Explanation8", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Make an interface with a method. We refer to this interface as `Component`..
        /// </summary>
        internal static string Step1 {
            get {
                return ResourceManager.GetString("Step1", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Make a class that implements Component. Also implement the method. We refer to this class as `ConcreteComponent`..
        /// </summary>
        internal static string Step2 {
            get {
                return ResourceManager.GetString("Step2", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Make an abstract class that implements Component. Implement the method of Component by making it virtual. Give it a private field with type Component. We refer to this class as `Decorator`..
        /// </summary>
        internal static string Step3 {
            get {
                return ResourceManager.GetString("Step3", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Give Decorator a non-private constructor with a parameter that gets assigned to the field. .
        /// </summary>
        internal static string Step4 {
            get {
                return ResourceManager.GetString("Step4", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to In Decorator, call the method of the field in the implementation of the method..
        /// </summary>
        internal static string Step5 {
            get {
                return ResourceManager.GetString("Step5", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Make a class that inherits from Decorator. Override its method by calling the method of Decorator; base.Method(). We refer to this class as `ConcreteDecorator`..
        /// </summary>
        internal static string Step6 {
            get {
                return ResourceManager.GetString("Step6", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Add a method to ConcreteDecorator providing additional behavior and call it in the overrided method either before or after the call to the parent&apos;s method..
        /// </summary>
        internal static string Step7 {
            get {
                return ResourceManager.GetString("Step7", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Make a class with a method that instantiates an instance of ConcreteDecorator by passing to its constructor a new instance of ConcreteComponent. Now call the method of the instantiated variable..
        /// </summary>
        internal static string Step8 {
            get {
                return ResourceManager.GetString("Step8", resourceCulture);
            }
        }
    }
}
