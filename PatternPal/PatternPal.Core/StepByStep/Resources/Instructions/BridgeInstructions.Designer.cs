//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace PatternPal.Core.StepByStep.Resources.Instructions {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class BridgeInstructions {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal BridgeInstructions() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("PatternPal.Core.StepByStep.Resources.Instructions.BridgeInstructions", typeof(BridgeInstructions).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This is the interface or abstract class that is the base for concrete implementation classes. .
        /// </summary>
        internal static string Explanation1 {
            get {
                return ResourceManager.GetString("Explanation1", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This class can provide a high-level control logic. It relies on the implementation object to do the actual low-level work. It stores a Concrete Implementation instance in the property or field. .
        /// </summary>
        internal static string Explanation2 {
            get {
                return ResourceManager.GetString("Explanation2", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This method is used to execute the actual low-level work that is defined in a Concrete Implementation instance. It only communicates with a Concrete Implementation through the Implementation Interface or Abstract Class..
        /// </summary>
        internal static string Explanation3 {
            get {
                return ResourceManager.GetString("Explanation3", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to It is time to make it possible that the field or property you created in step 2 has a value. If you created a property this will be enough, if you made a field you should make a constructor or method to do this. .
        /// </summary>
        internal static string Explanation4 {
            get {
                return ResourceManager.GetString("Explanation4", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This is a Concrete Implementation Class in which you can define the low-level work that an instance of the Abstraction Class can use. .
        /// </summary>
        internal static string Explanation5 {
            get {
                return ResourceManager.GetString("Explanation5", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This class can be used to define some more specific high-level work..
        /// </summary>
        internal static string Explanation6 {
            get {
                return ResourceManager.GetString("Explanation6", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This Client Class is used to control and use the Bridge pattern. .
        /// </summary>
        internal static string Explanation7 {
            get {
                return ResourceManager.GetString("Explanation7", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to In order to complete the use of the Bridge pattern you should create a Concrete Implementation that the Abstraction class will use to execute the work. .
        /// </summary>
        internal static string Explanation8 {
            get {
                return ResourceManager.GetString("Explanation8", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Make an interface or abstract class with a (if possible: abstract) method. We will refer to this as the Implementation Interface or Abstract Class..
        /// </summary>
        internal static string Step1 {
            get {
                return ResourceManager.GetString("Step1", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Make a class with a private or protected field or property with an Implementation type. We will refer to this class as the Abstraction Class..
        /// </summary>
        internal static string Step2 {
            get {
                return ResourceManager.GetString("Step2", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Make a method in the Abstraction class that calls the method in the Implementation Interface or Abstract Class..
        /// </summary>
        internal static string Step3 {
            get {
                return ResourceManager.GetString("Step3", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to If you chose to create a field in step 2, you should create a constructor or method with a parameter with the Implementation type that sets the field of step 2 to the value of the parameter..
        /// </summary>
        internal static string Step4 {
            get {
                return ResourceManager.GetString("Step4", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Make a class that implements the Implementation Interface or inherits from the Implementation Abstract Class. If it inherits from the Abstract Class it should override the abstract method. We will refer to this as the Concrete Implementation Class. .
        /// </summary>
        internal static string Step5 {
            get {
                return ResourceManager.GetString("Step5", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Make a class that inherits from the Abstraction class and has a method. This class is called the Refined Abstraction Class..
        /// </summary>
        internal static string Step6 {
            get {
                return ResourceManager.GetString("Step6", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Make a class that uses a method in the Abstraction Class. We will refer to this class as the Client Class..
        /// </summary>
        internal static string Step7 {
            get {
                return ResourceManager.GetString("Step7", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Let the Client Class create a Concrete Implementation instance and pass it through either a property, constructor or method to the Abstraction class..
        /// </summary>
        internal static string Step8 {
            get {
                return ResourceManager.GetString("Step8", resourceCulture);
            }
        }
    }
}
